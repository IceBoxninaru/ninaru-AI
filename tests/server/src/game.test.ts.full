import { jest } from '@jest/globals';
import { Game } from '../../../server/src/game.js';
import { WeatherKind, StatusEffectType, ElementKind, GamePhase } from '../../../shared/types/game.js';
import { Server, Socket } from 'socket.io';
import { createServer } from 'http';
import { GameService } from '../../../server/src/services/GameService.js';
import {
  IPlayer,
  Card,
  GameState,
  CardType,
  CardRarity,
  ICardData
} from '../../../shared/types/game.js';

// socket.ioのモックを改善
const mockSocket = {
  id: '',
  emit: jest.fn(),
  on: jest.fn(),
  join: jest.fn(),
  leave: jest.fn(),
  to: jest.fn().mockReturnThis(),
  broadcast: {
    emit: jest.fn()
  }
};

const mockServer = {
  emit: jest.fn(),
  to: jest.fn().mockReturnThis(),
  sockets: {
    emit: jest.fn(),
    adapter: {
      rooms: new Map(),
      sids: new Map()
    }
  }
};

jest.mock('socket.io', () => ({
  Server: jest.fn(() => mockServer)
}));

describe('ゲームロジック', () => {
  // タイムアウトを設定
  jest.setTimeout(30000);

  let game: Game;
  let mockSocket1: Socket;
  let mockSocket2: Socket;

  beforeEach(() => {
    jest.clearAllMocks();
    
    // モックソケットを作成
    mockSocket1 = {
      ...mockSocket,
      id: 'player1'
    } as unknown as Socket;

    mockSocket2 = {
      ...mockSocket,
      id: 'player2'
    } as unknown as Socket;

    const httpServer = createServer();
    const server = new Server(httpServer);
    
    game = new Game(server);
    game.addPlayer(mockSocket1, 'Player 1');
    game.addPlayer(mockSocket2, 'Player 2');
    game.start();

    // 初期状態を確認
    const state = game.getState();
    expect(state.players).toHaveLength(2);
    expect(state.currentPlayerId).toBe('player1');
  });

  describe('ゲーム初期化', () => {
    it('プレイヤーが正しく追加される', () => {
      const state = game.getState();
      expect(state.players).toHaveLength(2);
      expect(state.players[0].id).toBe('player1');
      expect(state.players[1].id).toBe('player2');
      expect(mockSocket1.emit).toHaveBeenCalled();
      expect(mockSocket2.emit).toHaveBeenCalled();
    });

    it('各プレイヤーが正しい初期状態を持つ', () => {
      const state = game.getState();
      state.players.forEach(player => {
        expect(player.hp).toBe(2000); // 修正：初期HPを2000に変更
        expect(player.maxHp).toBe(2000); // 修正：最大HPを2000に変更
        expect(player.mp).toBe(150); // 修正：初期MPを150に変更
        expect(player.faith).toBe(0);
        expect(player.deck).toHaveLength(30);
        expect(player.hand).toHaveLength(5);
        expect(player.statusEffects).toEqual([]);
      });
    });
  });

  describe('ターン管理', () => {
    it('ターンが正しく交代する', () => {
      const state = game.getState();
      expect(state.currentTurn).toBeGreaterThanOrEqual(0);
      expect(state.phase).toBe(GamePhase.MAIN);

      const currentPlayer = game.getCurrentPlayer();
      expect(currentPlayer).not.toBeNull();
      if (!currentPlayer) return;

      const currentPlayerId = currentPlayer.id;
      game.endTurn(currentPlayerId);
      const newState = game.getState();
      expect(newState.currentPlayerId).not.toBe(currentPlayerId);
    });

    it('ターン開始時にMPが回復する', () => {
      const player = game.getCurrentPlayer();
      expect(player).not.toBeNull();
      if (!player) return;

      player.mp = 0;
      game.endTurn(player.id);
      
      expect(player.mp).toBe(150); // 修正：MPを150に変更
    });
  });

  describe('カードプレイ', () => {
    it('カードを正しくプレイできる', () => {
      const currentPlayer = game.getCurrentPlayer();
      expect(currentPlayer).not.toBeNull();
      if (!currentPlayer) return;

      const players = game.getPlayers();
      const otherPlayer = players.find(p => p.id !== currentPlayer.id);
      expect(otherPlayer).not.toBeNull();
      if (!otherPlayer) return;

      // テスト用のカードを追加
      const testCard: ICardData = {
        id: 'test_card',
        name: 'テストカード',
        type: CardType.ATTACK,
        power: 100,
        element: ElementKind.NEUTRAL,
        mpCost: 10,
        description: 'テスト用カード',
        rarity: CardRarity.COMMON
      };

      currentPlayer.hand.push(testCard);
      const initialHp = otherPlayer.hp;

      game.playCard(currentPlayer.id, 0, otherPlayer.id);
      expect(otherPlayer.hp).toBeLessThan(initialHp);
    });

    it('MPが不足している場合はカードをプレイできない', () => {
      const player = game.getCurrentPlayer();
      expect(player).not.toBeNull();
      if (!player) return;

      // モックされたプレイヤーの手札にカードを追加
      const mockCard: ICardData = {
        id: 'card2',
        name: 'Expensive Card',
        type: CardType.ATTACK,
        mpCost: 1000, // 高コスト
        description: 'A test card',
        rarity: CardRarity.COMMON,
        power: 20
      };
      player.hand.push(mockCard);

      player.mp = 0;
      
      expect(() => {
        game.playCard(player.id, 0, 'id2');
      }).toThrow();
    });
  });

  describe('天候と状態異常', () => {
    it('天候が正しく更新される', () => {
      const initialWeather = game.getState().weather;
      const player1 = game.getPlayers()[0];
      const player2 = game.getPlayers()[1];
      
      expect(player1.id).toBe('player1');
      expect(player2.id).toBe('player2');
      
      // 天候の持続時間が経過するまでターンを進める
      const maxTurns = 5; // 安全のため最大ターン数を制限
      for (let i = 0; i < Math.min(initialWeather.duration + 1, maxTurns); i++) {
        expect(game.getState().currentPlayerId).toBe(player1.id);
        game.endTurn(player1.id);
        
        expect(game.getState().currentPlayerId).toBe(player2.id);
        game.endTurn(player2.id);
      }
      
      const newWeather = game.getState().weather;
      expect(newWeather.type).not.toBe(initialWeather.type);
    });

    it('状態異常が正しく適用される', () => {
      const player1 = game.getPlayers()[0];
      game.applyStatusEffect(player1.id, StatusEffectType.BURN);
      const updatedPlayer = game.getPlayer(player1.id);
      expect(updatedPlayer).not.toBeNull();
      if (!updatedPlayer) return;

      expect(updatedPlayer.statusEffects).toContainEqual(expect.objectContaining({
        type: StatusEffectType.BURN
      }));
    });

    describe('ステータス効果', () => {
      beforeEach(() => {
        // 各テストの前にゲームを初期状態に戻す
        const httpServer = createServer();
        const server = new Server(httpServer);
        game = new Game(server);
        game.addPlayer(mockSocket1, 'Player 1');
        game.addPlayer(mockSocket2, 'Player 2');
        game.start();
      });

      it('毒効果：ターン開始時にダメージを受ける', () => {
        const player = game.getCurrentPlayer();
        expect(player).not.toBeNull();
        if (!player) return;

        const initialHp = player.hp;
        game.applyStatusEffect(player.id, StatusEffectType.POISON);
        
        // 次のターンまで進める
        const otherPlayer = game.getPlayers().find(p => p.id !== player.id);
        expect(otherPlayer).not.toBeNull();
        if (!otherPlayer) return;
        
        game.endTurn(player.id);
        game.endTurn(otherPlayer.id);
        
        expect(player.hp).toBeLessThan(initialHp);
      });

      it('凍結効果：MPコストが増加する', () => {
        const player = game.getCurrentPlayer();
        expect(player).not.toBeNull();
        if (!player) return;

        const initialMpCostMultiplier = player.mpCostMultiplier;
        game.applyStatusEffect(player.id, StatusEffectType.FREEZE);
        expect(player.mpCostMultiplier).toBeGreaterThan(initialMpCostMultiplier);
      });

      it('シールド効果：受けるダメージが減少する', () => {
        const player = game.getCurrentPlayer();
        expect(player).not.toBeNull();
        if (!player) return;

        const initialDamageReceivedMultiplier = player.damageReceivedMultiplier;
        game.applyStatusEffect(player.id, StatusEffectType.SHIELD);
        expect(player.damageReceivedMultiplier).toBeLessThan(initialDamageReceivedMultiplier);
      });

      it('燃焼効果：継続ダメージが発生する', () => {
        const player = game.getCurrentPlayer();
        expect(player).not.toBeNull();
        if (!player) return;

        const initialHp = player.hp;
        game.applyStatusEffect(player.id, StatusEffectType.BURN);
        
        // 次のターンまで進める
        const otherPlayer = game.getPlayers().find(p => p.id !== player.id);
        expect(otherPlayer).not.toBeNull();
        if (!otherPlayer) return;
        
        game.endTurn(player.id);
        game.endTurn(otherPlayer.id);
        
        expect(player.hp).toBeLessThan(initialHp);
      });

      it('再生効果：ターン開始時にHP回復する', () => {
        const player = game.getCurrentPlayer();
        expect(player).not.toBeNull();
        if (!player) return;

        player.hp = 1500;
        const damagedHp = player.hp;
        game.applyStatusEffect(player.id, StatusEffectType.REGENERATION);
        
        // 次のターンまで進める
        const otherPlayer = game.getPlayers().find(p => p.id !== player.id);
        expect(otherPlayer).not.toBeNull();
        if (!otherPlayer) return;
        
        game.endTurn(player.id);
        game.endTurn(otherPlayer.id);
        
        expect(player.hp).toBeGreaterThan(damagedHp);
        expect(player.hp).toBeLessThanOrEqual(player.maxHp);
      });

      it('スタン効果：行動できない', () => {
        const player = game.getCurrentPlayer();
        expect(player).not.toBeNull();
        if (!player) return;

        game.applyStatusEffect(player.id, StatusEffectType.STUN);
        const testCard: ICardData = {
          id: 'stun-test-card',
          name: 'Test Card',
          type: CardType.ATTACK,
          mpCost: 10,
          description: 'Test card',
          rarity: CardRarity.COMMON,
          power: 50
        };
        player.hand.push(testCard);

        const otherPlayer = game.getPlayers().find(p => p.id !== player.id);
        expect(otherPlayer).not.toBeNull();
        if (!otherPlayer) return;

        expect(() => {
          game.playCard(player.id, player.hand.length - 1, otherPlayer.id);
        }).toThrow();
      });

      it('複数のステータス効果が同時に適用される', () => {
        const player = game.getCurrentPlayer();
        expect(player).not.toBeNull();
        if (!player) return;

        game.applyStatusEffect(player.id, StatusEffectType.POISON);
        game.applyStatusEffect(player.id, StatusEffectType.SHIELD);
        game.applyStatusEffect(player.id, StatusEffectType.REGENERATION);

        expect(player.statusEffects.length).toBe(3);
        const effectTypes = player.statusEffects.map(effect => effect.type);
        expect(effectTypes).toContain(StatusEffectType.POISON);
        expect(effectTypes).toContain(StatusEffectType.SHIELD);
        expect(effectTypes).toContain(StatusEffectType.REGENERATION);
      });

      it('ステータス効果の持続時間が正しく減少する', () => {
        const player = game.getCurrentPlayer();
        expect(player).not.toBeNull();
        if (!player) return;

        game.applyStatusEffect(player.id, StatusEffectType.BURN);
        const initialEffects = player.statusEffects.length;
        
        // 3ターン進める
        const otherPlayer = game.getPlayers().find(p => p.id !== player.id);
        expect(otherPlayer).not.toBeNull();
        if (!otherPlayer) return;
        
        for (let i = 0; i < 3; i++) {
          game.endTurn(player.id);
          game.endTurn(otherPlayer.id);
        }
        
        expect(player.statusEffects.length).toBeLessThan(initialEffects);
      });
    });
  });

  describe('勝利条件', () => {
    it('HPが0になったプレイヤーが負ける', () => {
      const player = game.getCurrentPlayer();
      expect(player).not.toBeNull();
      if (!player) return;

      player.hp = 0;
      
      const gameOver = game.checkGameOver();
      expect(gameOver).toBe(true);
      expect(game.getWinner()).toBe('id2');
    });
  });
}); 